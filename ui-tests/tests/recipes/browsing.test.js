const { test, describe, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert');\nrequire('dotenv').config();\n\nconst BrowserManager = require('../../helpers/browser');\nconst AuthHelper = require('../../helpers/auth');\nconst RecipeHelper = require('../../helpers/recipes');\nconst { searchQueries, filterOptions } = require('../../helpers/fixtures');\n\ndescribe('Recipe Browsing and Search', () => {\n  let browser;\n  let auth;\n  let recipes;\n\n  beforeEach(async () => {\n    browser = new BrowserManager();\n    await browser.launch();\n    auth = new AuthHelper(browser);\n    recipes = new RecipeHelper(browser);\n  });\n\n  afterEach(async () => {\n    if (browser) {\n      await browser.close();\n    }\n  });\n\n  test('should display recipe list page correctly', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Verify recipe list elements are present\n      assert.ok(await browser.elementExists('[data-testid=\"recipe-list\"]'), 'Recipe list should be visible');\n      \n      // Check for search functionality\n      assert.ok(await browser.elementExists('[data-testid=\"recipe-search\"]'), 'Search input should be present');\n      \n      // Check for filtering options\n      const filterExists = await browser.elementExists('[data-testid=\"filter-section\"]') ||\n                          await browser.elementExists('[data-testid=\"category-filter\"]') ||\n                          await browser.elementExists('[data-testid=\"filters\"]');\n      assert.ok(filterExists, 'Filtering options should be available');\n      \n      // Check for sorting options\n      const sortExists = await browser.elementExists('[data-testid=\"sort-dropdown\"]') ||\n                        await browser.elementExists('[data-testid=\"sort-section\"]');\n      assert.ok(sortExists, 'Sorting options should be available');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-list-display', error);\n    }\n  });\n\n  test('should load and display recipe cards', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Wait for recipes to load\n      await browser.waitForElement('[data-testid=\"recipe-list\"]');\n      \n      // Get recipe results\n      const recipeResults = await recipes.getRecipeResults();\n      \n      // Verify recipes are loaded\n      assert.ok(recipeResults.length > 0, 'Should load at least one recipe');\n      \n      // Verify recipe card structure\n      const firstRecipe = recipeResults[0];\n      assert.ok(firstRecipe.title, 'Recipe should have a title');\n      assert.ok(firstRecipe.id, 'Recipe should have an ID');\n      \n      // Check for recipe card elements\n      assert.ok(await browser.elementExists('[data-testid^=\"recipe-card-\"]'), 'Recipe cards should be present');\n      assert.ok(await browser.elementExists('[data-testid=\"recipe-title\"]'), 'Recipe titles should be visible');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-cards-load', error);\n    }\n  });\n\n  test('should search recipes by keyword', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Test search with common query\n      const searchQuery = searchQueries.common[0]; // 'pasta'\n      const searchResults = await recipes.searchRecipes(searchQuery);\n      \n      // Verify search results\n      assert.ok(Array.isArray(searchResults), 'Search should return results array');\n      \n      if (searchResults.length > 0) {\n        // Verify search relevance\n        const hasRelevantResults = searchResults.some(recipe => \n          recipe.title?.toLowerCase().includes(searchQuery.toLowerCase()) ||\n          recipe.description?.toLowerCase().includes(searchQuery.toLowerCase())\n        );\n        \n        assert.ok(hasRelevantResults, `Search results should be relevant to \"${searchQuery}\"`);\n      }\n      \n      // Verify search input shows the query\n      const searchInputValue = await browser.getPage().$eval(\n        '[data-testid=\"recipe-search\"]',\n        el => el.value\n      );\n      assert.strictEqual(searchInputValue, searchQuery, 'Search input should show the entered query');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-search-keyword', error);\n    }\n  });\n\n  test('should handle empty search results', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Search for something that likely won't exist\n      const nonExistentQuery = searchQueries.empty[0];\n      const searchResults = await recipes.searchRecipes(nonExistentQuery);\n      \n      // Check for empty state\n      if (searchResults.length === 0) {\n        // Verify empty state message\n        const emptyStateExists = await browser.elementExists('[data-testid=\"empty-results\"]') ||\n                               await browser.elementExists('[data-testid=\"no-recipes\"]') ||\n                               await browser.elementExists('[data-testid=\"empty-state\"]');\n        \n        if (emptyStateExists) {\n          assert.ok(true, 'Empty state message should be displayed for no results');\n        }\n      }\n      \n      // Verify search input still shows the query\n      const searchInputValue = await browser.getPage().$eval(\n        '[data-testid=\"recipe-search\"]',\n        el => el.value\n      );\n      assert.strictEqual(searchInputValue, nonExistentQuery, 'Search input should retain the query');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-search-empty', error);\n    }\n  });\n\n  test('should filter recipes by category', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Get initial results count\n      const initialResults = await recipes.getRecipeResults();\n      const initialCount = initialResults.length;\n      \n      // Apply category filter\n      const category = filterOptions.categories[0]; // 'appetizer'\n      const filteredResults = await recipes.filterByCategory(category);\n      \n      // Verify filtering works\n      if (filteredResults.length > 0 && filteredResults.length !== initialCount) {\n        // Check that filtered results match the category\n        const categoryMatches = filteredResults.every(recipe => \n          recipe.category?.toLowerCase().includes(category.toLowerCase())\n        );\n        \n        if (categoryMatches) {\n          assert.ok(true, `Filtered results should match category \"${category}\"`);\n        }\n      }\n      \n      // Verify filter UI is updated\n      const activeFilter = await browser.elementExists(`[data-testid=\"filter-category-${category}\"].active`) ||\n                          await browser.elementExists(`[data-testid=\"filter-category-${category}\"][aria-selected=\"true\"]`);\n      \n      if (activeFilter) {\n        assert.ok(true, 'Filter UI should show active state');\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-filter-category', error);\n    }\n  });\n\n  test('should sort recipes by different criteria', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Get initial results\n      const initialResults = await recipes.getRecipeResults();\n      \n      if (initialResults.length < 2) {\n        console.log('Not enough recipes to test sorting, skipping');\n        return;\n      }\n      \n      // Test different sort options\n      const sortOptions = ['newest', 'alphabetical'];\n      \n      for (const sortBy of sortOptions) {\n        if (await browser.elementExists(`[data-testid=\"sort-option-${sortBy}\"]`)) {\n          const sortedResults = await recipes.sortRecipes(sortBy);\n          \n          // Verify results are sorted\n          if (sortedResults.length > 1) {\n            if (sortBy === 'alphabetical') {\n              const titles = sortedResults.map(r => r.title).filter(t => t);\n              const sortedTitles = [...titles].sort();\n              \n              if (JSON.stringify(titles) === JSON.stringify(sortedTitles)) {\n                assert.ok(true, 'Results should be sorted alphabetically');\n              }\n            }\n            \n            // Verify sort UI is updated\n            const activeSortOption = await browser.elementExists(\n              `[data-testid=\"sort-option-${sortBy}\"].active`\n            ) || await browser.elementExists(\n              `[data-testid=\"sort-option-${sortBy}\"][aria-selected=\"true\"]`\n            );\n            \n            if (activeSortOption) {\n              assert.ok(true, `Sort option \"${sortBy}\" should be active`);\n            }\n          }\n        }\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-sort', error);\n    }\n  });\n\n  test('should combine search and filters', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // First apply a search\n      const searchQuery = 'chicken';\n      await recipes.searchRecipes(searchQuery, { waitForResults: true });\n      \n      // Then apply a category filter\n      const category = 'main-course';\n      if (await browser.elementExists(`[data-testid=\"filter-category-${category}\"]`)) {\n        await browser.clickElement(`[data-testid=\"filter-category-${category}\"]`);\n        \n        // Wait for combined results\n        await browser.waitForElement('[data-testid=\"recipe-list\"]');\n        \n        const combinedResults = await recipes.getRecipeResults();\n        \n        // Verify combined filtering\n        if (combinedResults.length > 0) {\n          const matchesBoth = combinedResults.every(recipe => {\n            const matchesSearch = recipe.title?.toLowerCase().includes(searchQuery.toLowerCase()) ||\n                                recipe.description?.toLowerCase().includes(searchQuery.toLowerCase());\n            const matchesCategory = recipe.category?.toLowerCase().includes(category.toLowerCase());\n            return matchesSearch && matchesCategory;\n          });\n          \n          if (matchesBoth) {\n            assert.ok(true, 'Results should match both search and filter criteria');\n          }\n        }\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-search-filter-combine', error);\n    }\n  });\n\n  test('should handle pagination if present', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Check if pagination exists\n      const paginationExists = await browser.elementExists('[data-testid=\"pagination\"]') ||\n                              await browser.elementExists('[data-testid=\"load-more\"]') ||\n                              await browser.elementExists('[data-testid=\"next-page\"]');\n      \n      if (!paginationExists) {\n        console.log('Pagination not found, skipping pagination test');\n        return;\n      }\n      \n      // Get initial results\n      const page1Results = await recipes.getRecipeResults();\n      const page1Count = page1Results.length;\n      \n      // Try to go to next page or load more\n      if (await browser.elementExists('[data-testid=\"next-page\"]')) {\n        await browser.clickElement('[data-testid=\"next-page\"]');\n        await browser.waitForElement('[data-testid=\"recipe-list\"]');\n        \n        const page2Results = await recipes.getRecipeResults();\n        \n        // Verify pagination worked\n        assert.ok(\n          page2Results.length > 0 && \n          JSON.stringify(page1Results) !== JSON.stringify(page2Results),\n          'Pagination should load different results'\n        );\n        \n      } else if (await browser.elementExists('[data-testid=\"load-more\"]')) {\n        await browser.clickElement('[data-testid=\"load-more\"]');\n        \n        // Wait for new recipes to load\n        await browser.getPage().waitForFunction((initialCount) => {\n          const cards = document.querySelectorAll('[data-testid^=\"recipe-card-\"]');\n          return cards.length > initialCount;\n        }, { timeout: 10000 }, page1Count).catch(() => {\n          // Continue if loading doesn't increase count\n        });\n        \n        const loadMoreResults = await recipes.getRecipeResults();\n        \n        assert.ok(\n          loadMoreResults.length >= page1Count,\n          'Load more should maintain or increase recipe count'\n        );\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-pagination', error);\n    }\n  });\n\n  test('should clear search and filters', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Apply search and filter\n      await recipes.searchRecipes('chicken');\n      \n      if (await browser.elementExists('[data-testid=\"filter-category-main-course\"]')) {\n        await browser.clickElement('[data-testid=\"filter-category-main-course\"]');\n      }\n      \n      // Check for clear/reset button\n      const clearButton = await browser.elementExists('[data-testid=\"clear-filters\"]') ||\n                         await browser.elementExists('[data-testid=\"reset-search\"]') ||\n                         await browser.elementExists('[data-testid=\"clear-all\"]');\n      \n      if (clearButton) {\n        const clearSelector = await browser.elementExists('[data-testid=\"clear-filters\"]') ?\n                             '[data-testid=\"clear-filters\"]' :\n                             (await browser.elementExists('[data-testid=\"reset-search\"]') ?\n                              '[data-testid=\"reset-search\"]' :\n                              '[data-testid=\"clear-all\"]');\n        \n        await browser.clickElement(clearSelector);\n        \n        // Verify search is cleared\n        const searchValue = await browser.getPage().$eval(\n          '[data-testid=\"recipe-search\"]',\n          el => el.value\n        );\n        assert.strictEqual(searchValue, '', 'Search input should be cleared');\n        \n        // Verify all recipes are shown again\n        const clearedResults = await recipes.getRecipeResults();\n        assert.ok(clearedResults.length > 0, 'Should show all recipes after clearing filters');\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-clear-filters', error);\n    }\n  });\n\n  test('should display recipe loading states', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Check for loading spinner or skeleton\n      const loadingExists = await browser.elementExists('[data-testid=\"loading-spinner\"]', 3000) ||\n                           await browser.elementExists('[data-testid=\"recipe-skeleton\"]', 3000) ||\n                           await browser.elementExists('[data-testid=\"loading\"]', 3000);\n      \n      if (loadingExists) {\n        assert.ok(true, 'Loading state should be displayed');\n        \n        // Wait for loading to complete\n        await browser.getPage().waitForFunction(() => {\n          const spinner = document.querySelector('[data-testid=\"loading-spinner\"]');\n          const skeleton = document.querySelector('[data-testid=\"recipe-skeleton\"]');\n          const loading = document.querySelector('[data-testid=\"loading\"]');\n          return (!spinner || spinner.style.display === 'none') &&\n                 (!skeleton || skeleton.style.display === 'none') &&\n                 (!loading || loading.style.display === 'none');\n        }, { timeout: 10000 }).catch(() => {\n          // Continue if loading state doesn't clear\n        });\n      }\n      \n      // Verify recipes are eventually loaded\n      const finalResults = await recipes.getRecipeResults();\n      assert.ok(finalResults.length >= 0, 'Recipes should be loaded after loading state');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-loading-states', error);\n    }\n  });\n\n  test('should handle search with special characters', async () => {\n    try {\n      await recipes.goToRecipesList();\n      \n      // Test search with special characters\n      const specialQueries = [\n        'cafÃ© latte',\n        'spicy & hot',\n        'mom\\'s recipe',\n        '100% organic'\n      ];\n      \n      for (const query of specialQueries) {\n        await recipes.searchRecipes(query, { waitForResults: true });\n        \n        // Verify search input handles special characters\n        const searchValue = await browser.getPage().$eval(\n          '[data-testid=\"recipe-search\"]',\n          el => el.value\n        );\n        assert.strictEqual(searchValue, query, `Search should handle special characters: \"${query}\"`);\n        \n        // Clear search for next test\n        await browser.fillInput('[data-testid=\"recipe-search\"]', '');\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-search-special-chars', error);\n    }\n  });\n\n  test('should be responsive on different screen sizes', async () => {\n    try {\n      // Test desktop view\n      await browser.getPage().setViewport({ width: 1920, height: 1080 });\n      await recipes.goToRecipesList();\n      \n      const desktopRecipes = await recipes.getRecipeResults();\n      assert.ok(desktopRecipes.length > 0, 'Should load recipes on desktop');\n      \n      // Test mobile view\n      await browser.getPage().setViewport({ width: 375, height: 667 });\n      await browser.getPage().reload({ waitUntil: 'networkidle0' });\n      \n      const mobileRecipes = await recipes.getRecipeResults();\n      assert.ok(mobileRecipes.length > 0, 'Should load recipes on mobile');\n      \n      // Verify search functionality works on mobile\n      if (await browser.elementExists('[data-testid=\"recipe-search\"]')) {\n        await recipes.searchRecipes('pasta');\n        const mobileSearchResults = await recipes.getRecipeResults();\n        assert.ok(Array.isArray(mobileSearchResults), 'Search should work on mobile');\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-responsive', error);\n    }\n  });\n});