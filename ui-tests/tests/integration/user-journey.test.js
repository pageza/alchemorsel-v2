const { test, describe, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert');\nrequire('dotenv').config();\n\nconst BrowserManager = require('../../helpers/browser');\nconst AuthHelper = require('../../helpers/auth');\nconst RecipeHelper = require('../../helpers/recipes');\nconst { generators, testRecipes, aiPrompts } = require('../../helpers/fixtures');\n\ndescribe('Complete User Journey Integration Tests', () => {\n  let browser;\n  let auth;\n  let recipes;\n\n  beforeEach(async () => {\n    browser = new BrowserManager();\n    await browser.launch();\n    auth = new AuthHelper(browser);\n    recipes = new RecipeHelper(browser);\n  });\n\n  afterEach(async () => {\n    if (browser) {\n      await browser.close();\n    }\n  });\n\n  test('complete new user journey: register -> browse -> favorite -> generate -> save', async () => {\n    try {\n      // Step 1: Visit landing page as guest\n      await browser.navigate('/');\n      assert.ok(\n        await browser.elementExists('[data-testid=\"landing-hero\"]') || \n        await browser.elementExists('[data-testid=\"welcome\"]'),\n        'Landing page should be displayed for guest users'\n      );\n      \n      // Step 2: Browse recipes as guest\n      await recipes.goToRecipesList();\n      const guestRecipes = await recipes.getRecipeResults();\n      assert.ok(guestRecipes.length > 0, 'Guest users should be able to browse recipes');\n      \n      // Step 3: Try to favorite as guest (should prompt login)\n      if (guestRecipes.length > 0) {\n        await recipes.viewRecipeDetails(guestRecipes[0].id);\n        \n        if (await browser.elementExists('[data-testid=\"favorite-button\"]')) {\n          await browser.clickElement('[data-testid=\"favorite-button\"]');\n          \n          // Should be redirected to login or see login prompt\n          const needsLogin = browser.getCurrentUrl().includes('/login') ||\n                           await browser.elementExists('[data-testid=\"login-prompt\"]', 3000);\n          \n          if (needsLogin) {\n            assert.ok(true, 'Guest users should be prompted to login for favoriting');\n          }\n        }\n      }\n      \n      // Step 4: Register new account\n      const newUser = generators.generateUser({\n        dietaryPreferences: ['vegetarian'],\n        allergies: ['nuts']\n      });\n      \n      const registrationSuccess = await auth.register(newUser);\n      assert.ok(registrationSuccess, 'User registration should be successful');\n      \n      // Step 5: Verify logged in and redirected to dashboard/home\n      const isLoggedIn = await auth.isLoggedIn();\n      assert.ok(isLoggedIn, 'User should be logged in after registration');\n      \n      // Step 6: Browse recipes as authenticated user\n      await recipes.goToRecipesList();\n      const authRecipes = await recipes.getRecipeResults();\n      assert.ok(authRecipes.length > 0, 'Authenticated users should be able to browse recipes');\n      \n      // Step 7: Favorite a recipe\n      if (authRecipes.length > 0) {\n        await recipes.viewRecipeDetails(authRecipes[0].id);\n        \n        if (await browser.elementExists('[data-testid=\"favorite-button\"]')) {\n          const favoriteSuccess = await recipes.toggleFavorite();\n          assert.ok(favoriteSuccess, 'Authenticated users should be able to favorite recipes');\n        }\n      }\n      \n      // Step 8: Generate AI recipe\n      await recipes.goToGenerateRecipe();\n      const generatedRecipe = await recipes.generateRecipeWithAI(aiPrompts.simple, {\n        waitForGeneration: true\n      });\n      \n      assert.ok(generatedRecipe, 'AI recipe generation should work for authenticated users');\n      assert.ok(generatedRecipe.title, 'Generated recipe should have a title');\n      \n      // Step 9: Save generated recipe\n      const saveResult = await recipes.saveGeneratedRecipe();\n      assert.ok(saveResult.success, 'Generated recipe should be saved successfully');\n      \n      // Step 10: View saved recipe\n      if (saveResult.recipeId) {\n        const savedRecipeDetails = await recipes.viewRecipeDetails(saveResult.recipeId);\n        assert.ok(savedRecipeDetails.title, 'Saved recipe should be viewable');\n      }\n      \n      // Step 11: Check favorites list\n      await recipes.goToFavorites();\n      const favoriteRecipes = await recipes.getFavoriteRecipes();\n      assert.ok(favoriteRecipes.length > 0, 'User should have favorites in their list');\n      \n      console.log('✅ Complete user journey test passed successfully');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('complete-user-journey', error);\n    }\n  });\n\n  test('recipe creation and management workflow', async () => {\n    try {\n      // Step 1: Login\n      await auth.loginAsTestUser();\n      \n      // Step 2: Create manual recipe\n      const newRecipe = generators.generateRecipe({\n        title: 'Integration Test Recipe',\n        description: 'A recipe created during integration testing',\n        ingredients: ['1 cup integration', '2 tbsp testing', '1 lb workflow'],\n        instructions: ['Prepare integration environment', 'Execute test workflow', 'Verify results']\n      });\n      \n      const createResult = await recipes.createRecipe(newRecipe);\n      assert.ok(createResult.success, 'Manual recipe creation should be successful');\n      \n      const createdRecipeId = createResult.recipeId;\n      assert.ok(createdRecipeId, 'Created recipe should have an ID');\n      \n      // Step 3: View created recipe\n      const recipeDetails = await recipes.viewRecipeDetails(createdRecipeId);\n      assert.strictEqual(recipeDetails.title, newRecipe.title, 'Created recipe should display correctly');\n      \n      // Step 4: Edit the recipe\n      const updates = {\n        title: 'Updated Integration Test Recipe',\n        description: 'Updated during integration testing'\n      };\n      \n      const editResult = await recipes.editRecipe(createdRecipeId, updates);\n      assert.ok(editResult.success, 'Recipe editing should be successful');\n      \n      // Step 5: Verify updates\n      const updatedDetails = await recipes.viewRecipeDetails(createdRecipeId);\n      assert.strictEqual(updatedDetails.title, updates.title, 'Recipe updates should be applied');\n      \n      // Step 6: Favorite the created recipe\n      const favoriteResult = await recipes.toggleFavorite(createdRecipeId);\n      assert.ok(favoriteResult, 'User should be able to favorite their own recipe');\n      \n      // Step 7: Verify in favorites list\n      await recipes.goToFavorites();\n      const favorites = await recipes.getFavoriteRecipes();\n      const isFavorited = favorites.some(fav => fav.id === createdRecipeId);\n      assert.ok(isFavorited, 'Created recipe should appear in favorites');\n      \n      // Step 8: Search for the created recipe\n      await recipes.goToRecipesList();\n      const searchResults = await recipes.searchRecipes(updates.title);\n      const foundInSearch = searchResults.some(recipe => recipe.id === createdRecipeId);\n      assert.ok(foundInSearch, 'Created recipe should be findable via search');\n      \n      console.log('✅ Recipe creation and management workflow test passed');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('recipe-management-workflow', error);\n    }\n  });\n\n  test('AI recipe generation and modification workflow', async () => {\n    try {\n      // Step 1: Login\n      await auth.loginAsTestUser();\n      \n      // Step 2: Generate initial recipe\n      await recipes.goToGenerateRecipe();\n      const initialPrompt = 'Create a healthy pasta dish with vegetables';\n      \n      const generatedRecipe = await recipes.generateRecipeWithAI(initialPrompt, {\n        waitForGeneration: true\n      });\n      \n      assert.ok(generatedRecipe, 'Initial recipe generation should succeed');\n      assert.ok(generatedRecipe.title, 'Generated recipe should have a title');\n      \n      // Step 3: Modify the recipe\n      const modificationPrompt = 'Make this recipe gluten-free and add more protein';\n      await recipes.modifyGeneratedRecipe(modificationPrompt);\n      \n      const modifiedRecipe = await recipes.getGeneratedRecipeData();\n      assert.ok(modifiedRecipe, 'Recipe modification should succeed');\n      \n      // Step 4: Save the modified recipe\n      const saveResult = await recipes.saveGeneratedRecipe();\n      assert.ok(saveResult.success, 'Modified recipe should be saved successfully');\n      \n      // Step 5: Verify saved recipe details\n      if (saveResult.recipeId) {\n        const savedDetails = await recipes.viewRecipeDetails(saveResult.recipeId);\n        assert.ok(savedDetails.title, 'Saved AI recipe should be viewable');\n        \n        // Step 6: Favorite the AI-generated recipe\n        const favoriteResult = await recipes.toggleFavorite(saveResult.recipeId);\n        assert.ok(favoriteResult, 'AI-generated recipe should be favoritable');\n      }\n      \n      // Step 7: Generate another recipe with different requirements\n      await recipes.goToGenerateRecipe();\n      const dietaryPrompt = 'Create a vegan dessert that is also sugar-free';\n      \n      const veganDessert = await recipes.generateRecipeWithAI(dietaryPrompt, {\n        waitForGeneration: true\n      });\n      \n      assert.ok(veganDessert, 'AI should handle specific dietary requirements');\n      \n      if (veganDessert.ingredients) {\n        const hasNonVeganIngredients = veganDessert.ingredients.some(ingredient => \n          ingredient.toLowerCase().includes('milk') || \n          ingredient.toLowerCase().includes('egg') ||\n          ingredient.toLowerCase().includes('butter')\n        );\n        \n        if (!hasNonVeganIngredients) {\n          assert.ok(true, 'AI should respect dietary restrictions in generated recipes');\n        }\n      }\n      \n      console.log('✅ AI recipe generation and modification workflow test passed');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('ai-generation-workflow', error);\n    }\n  });\n\n  test('profile and preferences integration workflow', async () => {\n    try {\n      // Step 1: Register with specific preferences\n      const userWithPrefs = generators.generateUser({\n        dietaryPreferences: ['vegetarian', 'gluten-free'],\n        allergies: ['nuts', 'dairy']\n      });\n      \n      await auth.register(userWithPrefs);\n      assert.ok(await auth.isLoggedIn(), 'User should be logged in after registration');\n      \n      // Step 2: Update profile with additional information\n      await browser.navigate('/profile/edit');\n      \n      if (await browser.elementExists('[data-testid=\"bio-input\"]')) {\n        await browser.fillInput('[data-testid=\"bio-input\"]', 'I love cooking healthy vegetarian meals!');\n      }\n      \n      // Update dietary preferences if possible\n      if (await browser.elementExists('[data-testid=\"dietary-vegan\"]')) {\n        await browser.clickElement('[data-testid=\"dietary-vegan\"]');\n      }\n      \n      // Save profile changes\n      if (await browser.elementExists('[data-testid=\"save-profile\"]')) {\n        await browser.clickElement('[data-testid=\"save-profile\"]');\n      }\n      \n      // Step 3: Generate recipe based on preferences\n      await recipes.goToGenerateRecipe();\n      const preferenceBasedPrompt = 'Create a recipe that matches my dietary preferences';\n      \n      const personalizedRecipe = await recipes.generateRecipeWithAI(preferenceBasedPrompt, {\n        waitForGeneration: true\n      });\n      \n      if (personalizedRecipe && personalizedRecipe.ingredients) {\n        // Check if AI respects user preferences\n        const hasAllergens = personalizedRecipe.ingredients.some(ingredient => \n          ingredient.toLowerCase().includes('nuts') || \n          ingredient.toLowerCase().includes('dairy')\n        );\n        \n        if (!hasAllergens) {\n          assert.ok(true, 'AI should respect user allergies in recipe generation');\n        }\n      }\n      \n      // Step 4: Browse recipes and check for preference-based filtering\n      await recipes.goToRecipesList();\n      \n      // Apply dietary filter that matches user preferences\n      if (await browser.elementExists('[data-testid=\"filter-category-vegetarian\"]')) {\n        await recipes.filterByCategory('vegetarian');\n        const filteredRecipes = await recipes.getRecipeResults();\n        assert.ok(filteredRecipes.length > 0, 'Filtering by user preferences should show relevant recipes');\n      }\n      \n      // Step 5: Search for recipes that match preferences\n      const preferenceSearch = await recipes.searchRecipes('vegetarian gluten-free');\n      assert.ok(Array.isArray(preferenceSearch), 'Search should work with preference keywords');\n      \n      console.log('✅ Profile and preferences integration workflow test passed');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('profile-preferences-workflow', error);\n    }\n  });\n\n  test('cross-device session persistence workflow', async () => {\n    try {\n      // Step 1: Login and perform actions\n      await auth.loginAsTestUser();\n      \n      // Get auth token\n      const authToken = await auth.getAuthToken();\n      assert.ok(authToken, 'Auth token should be available after login');\n      \n      // Step 2: Favorite a recipe\n      await recipes.goToRecipesList();\n      const recipeList = await recipes.getRecipeResults();\n      \n      if (recipeList.length > 0) {\n        await recipes.viewRecipeDetails(recipeList[0].id);\n        if (await browser.elementExists('[data-testid=\"favorite-button\"]')) {\n          await recipes.toggleFavorite();\n        }\n      }\n      \n      // Step 3: Simulate page refresh (session persistence)\n      await browser.getPage().reload({ waitUntil: 'networkidle0' });\n      \n      // Verify still logged in after refresh\n      const stillLoggedIn = await auth.isLoggedIn();\n      assert.ok(stillLoggedIn, 'User should remain logged in after page refresh');\n      \n      // Step 4: Navigate to different page and back\n      await browser.navigate('/');\n      await browser.navigate('/dashboard');\n      \n      // Verify still logged in after navigation\n      const loggedInAfterNavigation = await auth.isLoggedIn();\n      assert.ok(loggedInAfterNavigation, 'User should remain logged in after navigation');\n      \n      // Step 5: Open new tab (simulate multi-tab usage)\n      const secondPage = await browser.getBrowser().newPage();\n      await secondPage.goto(process.env.BASE_URL || 'http://localhost:5173');\n      \n      // Check if logged in in new tab\n      const tokenInSecondTab = await secondPage.evaluate(() => {\n        return localStorage.getItem('auth-token') || localStorage.getItem('token');\n      });\n      \n      assert.ok(tokenInSecondTab, 'Auth token should be available in new tab');\n      \n      await secondPage.close();\n      \n      // Step 6: Check favorites persistence\n      await recipes.goToFavorites();\n      const persistedFavorites = await recipes.getFavoriteRecipes();\n      \n      if (recipeList.length > 0) {\n        const hasFavorites = persistedFavorites.length > 0;\n        if (hasFavorites) {\n          assert.ok(true, 'Favorites should persist across sessions');\n        }\n      }\n      \n      console.log('✅ Cross-device session persistence workflow test passed');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('session-persistence-workflow', error);\n    }\n  });\n\n  test('error handling and recovery workflow', async () => {\n    try {\n      // Step 1: Login\n      await auth.loginAsTestUser();\n      \n      // Step 2: Simulate network error during recipe browsing\n      await browser.navigate('/recipes');\n      \n      // Temporarily disable network\n      await browser.getPage().setOfflineMode(true);\n      \n      // Try to refresh page\n      await browser.getPage().reload().catch(() => {\n        // Expected to fail in offline mode\n      });\n      \n      // Re-enable network\n      await browser.getPage().setOfflineMode(false);\n      \n      // Verify recovery\n      await browser.getPage().reload({ waitUntil: 'networkidle0' });\n      assert.ok(\n        await browser.elementExists('[data-testid=\"recipe-list\"]'),\n        'App should recover from network errors'\n      );\n      \n      // Step 3: Test form validation and error recovery\n      await recipes.goToCreateRecipe();\n      \n      // Submit empty form to trigger validation\n      await browser.clickElement('[data-testid=\"save-recipe\"]');\n      \n      // Check for validation errors\n      const hasValidationErrors = await browser.elementExists('[data-testid=\"validation-error\"]', 3000) ||\n                                 await browser.elementExists('[data-testid=\"title-error\"]', 3000);\n      \n      if (hasValidationErrors) {\n        // Fix validation errors\n        await browser.fillInput('[data-testid=\"recipe-title\"]', 'Error Recovery Test Recipe');\n        \n        if (await browser.elementExists('[data-testid=\"ingredient-0\"]')) {\n          await browser.fillInput('[data-testid=\"ingredient-0\"]', 'Test ingredient');\n        }\n        \n        if (await browser.elementExists('[data-testid=\"instruction-0\"]')) {\n          await browser.fillInput('[data-testid=\"instruction-0\"]', 'Test instruction');\n        }\n        \n        // Save should now work\n        await browser.clickElement('[data-testid=\"save-recipe\"]');\n        \n        // Verify successful save\n        const currentUrl = browser.getCurrentUrl();\n        if (currentUrl.includes('/recipes/') && !currentUrl.includes('/create')) {\n          assert.ok(true, 'Form should submit successfully after fixing validation errors');\n        }\n      }\n      \n      // Step 4: Test authentication error recovery\n      // Simulate expired token\n      await browser.getPage().evaluate(() => {\n        localStorage.setItem('auth-token', 'expired.token.here');\n      });\n      \n      // Try to access protected resource\n      await browser.navigate('/dashboard');\n      \n      // Should be redirected to login\n      const redirectedToLogin = browser.getCurrentUrl().includes('/login');\n      if (redirectedToLogin) {\n        assert.ok(true, 'App should handle expired tokens by redirecting to login');\n        \n        // Re-login should work\n        await auth.loginAsTestUser();\n        assert.ok(await auth.isLoggedIn(), 'User should be able to re-login after token expiration');\n      }\n      \n      console.log('✅ Error handling and recovery workflow test passed');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('error-recovery-workflow', error);\n    }\n  });\n});