const { test, describe, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert');\nrequire('dotenv').config();\n\nconst BrowserManager = require('../../helpers/browser');\nconst AuthHelper = require('../../helpers/auth');\nconst { generators } = require('../../helpers/fixtures');\n\ndescribe('Authentication - Logout Flow', () => {\n  let browser;\n  let auth;\n\n  beforeEach(async () => {\n    browser = new BrowserManager();\n    await browser.launch();\n    auth = new AuthHelper(browser);\n  });\n\n  afterEach(async () => {\n    if (browser) {\n      await browser.close();\n    }\n  });\n\n  test('should successfully logout when logged in', async () => {\n    try {\n      // First login\n      await auth.loginAsTestUser();\n      assert.ok(await auth.isLoggedIn(), 'User should be logged in initially');\n      \n      // Perform logout\n      const logoutSuccess = await auth.logout();\n      assert.ok(logoutSuccess, 'Logout should be successful');\n      \n      // Verify user is logged out\n      const isLoggedIn = await auth.isLoggedIn();\n      assert.ok(!isLoggedIn, 'User should be logged out after logout');\n      \n      // Verify redirect to public page\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(\n        currentUrl.includes('/login') || currentUrl === '/' || currentUrl.includes('/recipes'),\n        `Should redirect to public page after logout, got: ${currentUrl}`\n      );\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-success', error);\n    }\n  });\n\n  test('should clear authentication token on logout', async () => {\n    try {\n      // Login and verify token exists\n      await auth.loginAsTestUser();\n      const tokenBeforeLogout = await auth.getAuthToken();\n      assert.ok(tokenBeforeLogout, 'Auth token should exist after login');\n      \n      // Logout\n      await auth.logout();\n      \n      // Verify token is cleared\n      const tokenAfterLogout = await auth.getAuthToken();\n      assert.ok(!tokenAfterLogout, 'Auth token should be cleared after logout');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-clear-token', error);\n    }\n  });\n\n  test('should clear user session data on logout', async () => {\n    try {\n      // Login and verify user data exists\n      await auth.loginAsTestUser();\n      const userBeforeLogout = await auth.getCurrentUser();\n      assert.ok(userBeforeLogout, 'User data should exist after login');\n      \n      // Logout\n      await auth.logout();\n      \n      // Verify user data is cleared\n      const userAfterLogout = await auth.getCurrentUser();\n      assert.ok(!userAfterLogout, 'User data should be cleared after logout');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-clear-session', error);\n    }\n  });\n\n  test('should handle logout from user menu dropdown', async () => {\n    try {\n      // Login first\n      await auth.loginAsTestUser();\n      \n      // Navigate to a page where user menu should be visible\n      await browser.navigate('/dashboard');\n      \n      // Check if user menu dropdown exists\n      if (await browser.elementExists('[data-testid=\"user-menu\"]')) {\n        // Click user menu to open dropdown\n        await browser.clickElement('[data-testid=\"user-menu\"]');\n        \n        // Wait for dropdown to appear\n        await browser.waitForElement('[data-testid=\"logout-button\"]');\n        \n        // Click logout from dropdown\n        await Promise.all([\n          browser.waitForNavigation(),\n          browser.clickElement('[data-testid=\"logout-button\"]')\n        ]);\n        \n        // Verify logout success\n        const isLoggedIn = await auth.isLoggedIn();\n        assert.ok(!isLoggedIn, 'User should be logged out from dropdown menu');\n        \n      } else {\n        console.log('User menu dropdown not found, checking for direct logout button');\n        \n        // Try direct logout button\n        if (await browser.elementExists('[data-testid=\"logout-button\"]')) {\n          await Promise.all([\n            browser.waitForNavigation(),\n            browser.clickElement('[data-testid=\"logout-button\"]')\n          ]);\n          \n          const isLoggedIn = await auth.isLoggedIn();\n          assert.ok(!isLoggedIn, 'User should be logged out from direct button');\n        } else {\n          console.log('No logout button found, test may need UI updates');\n        }\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-user-menu', error);\n    }\n  });\n\n  test('should redirect to login when accessing protected page after logout', async () => {\n    try {\n      // Login and navigate to protected page\n      await auth.loginAsTestUser();\n      await browser.navigate('/dashboard');\n      \n      // Verify we can access protected page\n      assert.ok(\n        browser.getCurrentUrl().includes('/dashboard'),\n        'Should be able to access dashboard when logged in'\n      );\n      \n      // Logout\n      await auth.logout();\n      \n      // Try to access protected page again\n      await browser.navigate('/dashboard');\n      \n      // Should be redirected to login\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(\n        currentUrl.includes('/login'),\n        'Should be redirected to login when accessing protected page after logout'\n      );\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-protected-redirect', error);\n    }\n  });\n\n  test('should handle logout from multiple browser tabs', async () => {\n    try {\n      // Login in first tab\n      await auth.loginAsTestUser();\n      assert.ok(await auth.isLoggedIn(), 'Should be logged in initially');\n      \n      // Open second tab\n      const secondPage = await browser.getBrowser().newPage();\n      await secondPage.goto(process.env.BASE_URL || 'http://localhost:5173');\n      \n      // Verify login state in second tab\n      const tokenInSecondTab = await secondPage.evaluate(() => {\n        return localStorage.getItem('auth-token') || localStorage.getItem('token');\n      });\n      assert.ok(tokenInSecondTab, 'Should be logged in in second tab');\n      \n      // Logout from first tab\n      await auth.logout();\n      \n      // Check if second tab is also logged out (depends on implementation)\n      await secondPage.reload();\n      const tokenAfterLogout = await secondPage.evaluate(() => {\n        return localStorage.getItem('auth-token') || localStorage.getItem('token');\n      });\n      \n      // This test checks if logout syncs across tabs\n      // The expectation may vary based on implementation\n      if (!tokenAfterLogout) {\n        assert.ok(true, 'Logout synced across tabs');\n      } else {\n        console.log('Logout did not sync across tabs - this may be expected behavior');\n      }\n      \n      await secondPage.close();\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-multiple-tabs', error);\n    }\n  });\n\n  test('should handle logout when session expires', async () => {\n    try {\n      // Login first\n      await auth.loginAsTestUser();\n      \n      // Simulate expired token by modifying the stored token\n      await browser.getPage().evaluate(() => {\n        const expiredToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyMzkwMjJ9.invalid';\n        localStorage.setItem('auth-token', expiredToken);\n      });\n      \n      // Try to access a protected page\n      await browser.navigate('/dashboard');\n      \n      // Should be redirected to login due to expired token\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(\n        currentUrl.includes('/login'),\n        'Should be redirected to login with expired token'\n      );\n      \n      // Verify user appears logged out\n      const isLoggedIn = await auth.isLoggedIn();\n      assert.ok(!isLoggedIn, 'User should appear logged out with expired token');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-expired-session', error);\n    }\n  });\n\n  test('should handle logout button visibility states', async () => {\n    try {\n      // When not logged in, logout button should not be visible\n      await browser.navigate('/');\n      const logoutVisibleWhenLoggedOut = await browser.elementExists('[data-testid=\"logout-button\"]', 2000);\n      \n      if (logoutVisibleWhenLoggedOut) {\n        console.log('Logout button visible when not logged in - may need UI update');\n      }\n      \n      // Login\n      await auth.loginAsTestUser();\n      \n      // Navigate to authenticated area\n      await browser.navigate('/dashboard');\n      \n      // Logout button should be visible when logged in\n      const logoutVisibleWhenLoggedIn = await browser.elementExists('[data-testid=\"logout-button\"]', 5000) ||\n                                       await browser.elementExists('[data-testid=\"user-menu\"]', 5000);\n      \n      assert.ok(logoutVisibleWhenLoggedIn, 'Logout option should be visible when logged in');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-button-visibility', error);\n    }\n  });\n\n  test('should handle network errors during logout', async () => {\n    try {\n      // Login first\n      await auth.loginAsTestUser();\n      \n      // Simulate network failure for logout request\n      await browser.getPage().setRequestInterception(true);\n      browser.getPage().on('request', (request) => {\n        if (request.url().includes('/logout') || request.url().includes('/auth/logout')) {\n          request.abort();\n        } else {\n          request.continue();\n        }\n      });\n      \n      // Attempt logout\n      if (await browser.elementExists('[data-testid=\"user-menu\"]')) {\n        await browser.clickElement('[data-testid=\"user-menu\"]');\n      }\n      \n      await browser.clickElement('[data-testid=\"logout-button\"]');\n      \n      // Even with network error, client-side logout should still work\n      // (clearing tokens and redirecting)\n      const currentUrl = browser.getCurrentUrl();\n      const isLoggedIn = await auth.isLoggedIn();\n      \n      // Depending on implementation, logout might succeed locally even if API call fails\n      if (!isLoggedIn || currentUrl.includes('/login')) {\n        assert.ok(true, 'Logout handled gracefully despite network error');\n      } else {\n        console.log('Logout may require server confirmation - check implementation');\n      }\n      \n      // Restore normal request handling\n      await browser.getPage().setRequestInterception(false);\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-network-error', error);\n    }\n  });\n\n  test('should handle logout confirmation dialog if present', async () => {\n    try {\n      // Login first\n      await auth.loginAsTestUser();\n      await browser.navigate('/dashboard');\n      \n      // Find logout button\n      if (await browser.elementExists('[data-testid=\"user-menu\"]')) {\n        await browser.clickElement('[data-testid=\"user-menu\"]');\n      }\n      \n      // Click logout\n      await browser.clickElement('[data-testid=\"logout-button\"]');\n      \n      // Check if confirmation dialog appears\n      const confirmationExists = await browser.elementExists('[data-testid=\"logout-confirm\"]', 2000) ||\n                                await browser.elementExists('[data-testid=\"confirm-dialog\"]', 2000);\n      \n      if (confirmationExists) {\n        // Handle confirmation dialog\n        const confirmSelector = await browser.elementExists('[data-testid=\"logout-confirm\"]') ?\n                               '[data-testid=\"logout-confirm\"]' : '[data-testid=\"confirm-dialog\"]';\n        \n        await browser.clickElement(confirmSelector);\n      }\n      \n      // Wait for logout to complete\n      await browser.waitForNavigation().catch(() => {\n        // Continue if no navigation occurs\n      });\n      \n      // Verify logout success\n      const isLoggedIn = await auth.isLoggedIn();\n      assert.ok(!isLoggedIn, 'User should be logged out after confirmation');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-confirmation', error);\n    }\n  });\n\n  test('should maintain logout state after page refresh', async () => {\n    try {\n      // Login and then logout\n      await auth.loginAsTestUser();\n      await auth.logout();\n      \n      // Verify logged out state\n      assert.ok(!(await auth.isLoggedIn()), 'Should be logged out initially');\n      \n      // Refresh the page\n      await browser.getPage().reload({ waitUntil: 'networkidle0' });\n      \n      // Verify still logged out after refresh\n      assert.ok(!(await auth.isLoggedIn()), 'Should remain logged out after page refresh');\n      \n      // Try to access protected page\n      await browser.navigate('/dashboard');\n      \n      // Should still be redirected to login\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(\n        currentUrl.includes('/login'),\n        'Should still be redirected to login after refresh'\n      );\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('logout-persist-refresh', error);\n    }\n  });\n});