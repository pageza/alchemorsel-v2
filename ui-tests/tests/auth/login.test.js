const { test, describe, beforeEach, afterEach } = require('node:test');\nconst assert = require('node:assert');\nrequire('dotenv').config();\n\nconst BrowserManager = require('../../helpers/browser');\nconst AuthHelper = require('../../helpers/auth');\nconst { testUsers, validationTests } = require('../../helpers/fixtures');\n\ndescribe('Authentication - Login Flow', () => {\n  let browser;\n  let auth;\n\n  beforeEach(async () => {\n    browser = new BrowserManager();\n    await browser.launch();\n    auth = new AuthHelper(browser);\n  });\n\n  afterEach(async () => {\n    if (browser) {\n      await browser.close();\n    }\n  });\n\n  test('should display login form correctly', async () => {\n    try {\n      await auth.goToLogin();\n      \n      // Verify login form elements are present\n      assert.ok(await browser.elementExists('[data-testid=\"login-form\"]'), 'Login form should be visible');\n      assert.ok(await browser.elementExists('[data-testid=\"email-input\"]'), 'Email input should be present');\n      assert.ok(await browser.elementExists('[data-testid=\"password-input\"]'), 'Password input should be present');\n      assert.ok(await browser.elementExists('[data-testid=\"login-submit\"]'), 'Login button should be present');\n      \n      // Check for remember me checkbox\n      if (await browser.elementExists('[data-testid=\"remember-me\"]')) {\n        assert.ok(true, 'Remember me option is available');\n      }\n      \n      // Check for registration link\n      assert.ok(await browser.elementExists('[data-testid=\"register-link\"]'), 'Register link should be present');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-form-display', error);\n    }\n  });\n\n  test('should successfully login with valid credentials', async () => {\n    try {\n      // Create a test user first (this would typically be done in setup)\n      const testUser = {\n        email: process.env.TEST_USER_EMAIL || 'test@alchemorsel.com',\n        password: process.env.TEST_USER_PASSWORD || 'TestPassword123!'\n      };\n      \n      const loginSuccess = await auth.login(testUser.email, testUser.password);\n      \n      assert.ok(loginSuccess, 'Login should be successful');\n      \n      // Verify we're redirected to dashboard or home\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(\n        currentUrl.includes('/dashboard') || currentUrl === '/' || currentUrl.includes('/recipes'),\n        `Should redirect to dashboard or home after login, got: ${currentUrl}`\n      );\n      \n      // Verify user is logged in\n      const isLoggedIn = await auth.isLoggedIn();\n      assert.ok(isLoggedIn, 'User should be logged in after successful login');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-success', error);\n    }\n  });\n\n  test('should handle invalid email/password combination', async () => {\n    try {\n      await auth.goToLogin();\n      \n      const loginSuccess = await auth.login(\n        'invalid@example.com',\n        'wrongpassword',\n        { expectSuccess: false, waitForRedirect: false }\n      );\n      \n      assert.ok(!loginSuccess, 'Login should fail with invalid credentials');\n      \n      // Check for error message\n      const errorExists = await browser.elementExists('[data-testid=\"error-message\"]', 5000);\n      if (errorExists) {\n        const errorText = await browser.getElementText('[data-testid=\"error-message\"]');\n        assert.ok(\n          errorText.toLowerCase().includes('invalid') || \n          errorText.toLowerCase().includes('incorrect') ||\n          errorText.toLowerCase().includes('wrong'),\n          `Error message should indicate invalid credentials, got: ${errorText}`\n        );\n      }\n      \n      // Verify we stay on login page\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(currentUrl.includes('/login'), 'Should remain on login page after failed login');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-invalid-credentials', error);\n    }\n  });\n\n  test('should validate email format', async () => {\n    try {\n      await auth.goToLogin();\n      \n      for (const invalidEmail of validationTests.email.invalid) {\n        await browser.fillInput('[data-testid=\"email-input\"]', invalidEmail);\n        await browser.fillInput('[data-testid=\"password-input\"]', 'SomePassword123!');\n        \n        // Try to submit\n        await browser.clickElement('[data-testid=\"login-submit\"]');\n        \n        // Check for validation error\n        const hasValidationError = await browser.elementExists('[data-testid=\"email-error\"]', 2000) ||\n                                  await browser.elementExists('[data-testid=\"validation-error\"]', 2000);\n        \n        if (hasValidationError) {\n          assert.ok(true, `Email validation should catch invalid format: ${invalidEmail}`);\n        }\n        \n        // Clear the field for next test\n        await browser.fillInput('[data-testid=\"email-input\"]', '');\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-email-validation', error);\n    }\n  });\n\n  test('should handle empty form submission', async () => {\n    try {\n      await auth.goToLogin();\n      \n      // Try to submit empty form\n      await browser.clickElement('[data-testid=\"login-submit\"]');\n      \n      // Check that we stay on login page\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(currentUrl.includes('/login'), 'Should remain on login page with empty form');\n      \n      // Check for validation errors\n      const hasEmailError = await browser.elementExists('[data-testid=\"email-error\"]', 2000);\n      const hasPasswordError = await browser.elementExists('[data-testid=\"password-error\"]', 2000);\n      const hasGeneralError = await browser.elementExists('[data-testid=\"validation-error\"]', 2000);\n      \n      assert.ok(\n        hasEmailError || hasPasswordError || hasGeneralError,\n        'Should show validation errors for empty form'\n      );\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-empty-form', error);\n    }\n  });\n\n  test('should remember login state with remember me option', async () => {\n    try {\n      // Only run this test if remember me option exists\n      await auth.goToLogin();\n      \n      if (!(await browser.elementExists('[data-testid=\"remember-me\"]'))) {\n        console.log('Remember me option not found, skipping test');\n        return;\n      }\n      \n      const testUser = {\n        email: process.env.TEST_USER_EMAIL || 'test@alchemorsel.com',\n        password: process.env.TEST_USER_PASSWORD || 'TestPassword123!'\n      };\n      \n      // Login with remember me enabled\n      const loginSuccess = await auth.login(testUser.email, testUser.password, {\n        rememberMe: true\n      });\n      \n      assert.ok(loginSuccess, 'Login with remember me should be successful');\n      \n      // Get auth token\n      const token = await auth.getAuthToken();\n      assert.ok(token, 'Auth token should be stored');\n      \n      // Logout and check if token persists in localStorage (vs sessionStorage)\n      await auth.logout();\n      \n      // Navigate to a new page and back to test persistence\n      await browser.navigate('/');\n      await browser.navigate('/login');\n      \n      // Check if we're still logged in or token is available for auto-login\n      const persistedToken = await auth.getAuthToken();\n      assert.ok(persistedToken, 'Token should persist with remember me option');\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-remember-me', error);\n    }\n  });\n\n  test('should handle network errors gracefully', async () => {\n    try {\n      await auth.goToLogin();\n      \n      // Simulate network failure by intercepting requests\n      await browser.getPage().setRequestInterception(true);\n      browser.getPage().on('request', (request) => {\n        if (request.url().includes('/api/v1/auth/login')) {\n          request.abort();\n        } else {\n          request.continue();\n        }\n      });\n      \n      // Try to login\n      await browser.fillInput('[data-testid=\"email-input\"]', 'test@example.com');\n      await browser.fillInput('[data-testid=\"password-input\"]', 'password123');\n      await browser.clickElement('[data-testid=\"login-submit\"]');\n      \n      // Check for network error handling\n      const errorExists = await browser.elementExists('[data-testid=\"error-message\"]', 10000);\n      if (errorExists) {\n        const errorText = await browser.getElementText('[data-testid=\"error-message\"]');\n        assert.ok(\n          errorText.toLowerCase().includes('network') || \n          errorText.toLowerCase().includes('connection') ||\n          errorText.toLowerCase().includes('error'),\n          `Should show network error message, got: ${errorText}`\n        );\n      }\n      \n      // Restore normal request handling\n      await browser.getPage().setRequestInterception(false);\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-network-error', error);\n    }\n  });\n\n  test('should redirect to intended page after login', async () => {\n    try {\n      // Try to access protected page while not logged in\n      await browser.navigate('/dashboard');\n      \n      // Should be redirected to login\n      const currentUrl = browser.getCurrentUrl();\n      assert.ok(\n        currentUrl.includes('/login'),\n        'Should redirect to login when accessing protected page'\n      );\n      \n      // Login successfully\n      const testUser = {\n        email: process.env.TEST_USER_EMAIL || 'test@alchemorsel.com',\n        password: process.env.TEST_USER_PASSWORD || 'TestPassword123!'\n      };\n      \n      await auth.login(testUser.email, testUser.password);\n      \n      // Should be redirected back to intended page (dashboard)\n      const finalUrl = browser.getCurrentUrl();\n      assert.ok(\n        finalUrl.includes('/dashboard') || finalUrl.includes('/') || finalUrl.includes('/recipes'),\n        `Should redirect to intended page after login, got: ${finalUrl}`\n      );\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-redirect-intended', error);\n    }\n  });\n\n  test('should handle social login options if available', async () => {\n    try {\n      await auth.goToLogin();\n      \n      // Check for social login buttons\n      const socialButtons = [\n        '[data-testid=\"google-login\"]',\n        '[data-testid=\"facebook-login\"]',\n        '[data-testid=\"github-login\"]'\n      ];\n      \n      let socialOptionsFound = false;\n      for (const selector of socialButtons) {\n        if (await browser.elementExists(selector, 1000)) {\n          socialOptionsFound = true;\n          assert.ok(true, `Social login option found: ${selector}`);\n          \n          // Verify button is clickable (but don't actually click)\n          const button = await browser.waitForElement(selector);\n          const isEnabled = await browser.getPage().evaluate(\n            (el) => !el.disabled && !el.classList.contains('disabled'),\n            button\n          );\n          assert.ok(isEnabled, `Social login button should be enabled: ${selector}`);\n        }\n      }\n      \n      if (!socialOptionsFound) {\n        console.log('No social login options found, skipping social login test');\n      }\n      \n    } catch (error) {\n      await browser.screenshotOnFailure('login-social-options', error);\n    }\n  });\n});