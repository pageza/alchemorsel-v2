name: Deploy to Production

on:
  push:
    branches: [ master, main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment (skip some checks)'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: docker.io
  DOCKERHUB_USERNAME: alchemorsel
  BACKEND_IMAGE: alchemorsel/backend
  FRONTEND_IMAGE: alchemorsel/frontend

jobs:
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    outputs:
      backend-image: ${{ steps.backend.outputs.image }}
      frontend-image: ${{ steps.frontend.outputs.image }}
      tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
    
    - name: Get version
      id: version
      run: |
        if [ -f VERSION ]; then
          VERSION=$(cat VERSION)
        else
          VERSION="1.2.0"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$VERSION" >> $GITHUB_OUTPUT
    
    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.BACKEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=tag
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ steps.version.outputs.version }},enable={{is_default_branch}}

    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.FRONTEND_IMAGE }}
        tags: |
          type=ref,event=branch
          type=ref,event=tag
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=${{ steps.version.outputs.version }},enable={{is_default_branch}}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push backend image
      id: backend
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64
    
    - name: Build and push frontend image
      id: frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-images
    environment: staging
    if: github.ref == 'refs/heads/develop' || github.event.inputs.environment == 'staging'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy to staging
      env:
        BACKEND_IMAGE: ${{ needs.build-images.outputs.backend-image }}
        FRONTEND_IMAGE: ${{ needs.build-images.outputs.frontend-image }}
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_STAGING }}
      run: |
        echo "üöÄ Deploying to staging environment..."
        echo "Backend image: $BACKEND_IMAGE"
        echo "Frontend image: $FRONTEND_IMAGE"
        
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Setup kubeconfig
        mkdir -p ~/.kube
        echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
        
        # Deploy using Helm or kubectl
        # Replace with your actual deployment commands
        echo "Deploying backend..."
        kubectl set image deployment/alchemorsel-backend backend=$BACKEND_IMAGE -n staging
        
        echo "Deploying frontend..."
        kubectl set image deployment/alchemorsel-frontend frontend=$FRONTEND_IMAGE -n staging
        
        # Wait for rollout to complete
        kubectl rollout status deployment/alchemorsel-backend -n staging --timeout=300s
        kubectl rollout status deployment/alchemorsel-frontend -n staging --timeout=300s
        
        echo "‚úÖ Staging deployment completed"
    
    - name: Run staging smoke tests
      run: |
        echo "üß™ Running smoke tests on staging..."
        
        # Wait for services to be ready
        sleep 30
        
        STAGING_URL="https://staging.alchemorsel.com"
        
        # Test backend health
        curl -f "$STAGING_URL/api/health" || {
          echo "‚ùå Backend health check failed"
          exit 1
        }
        
        # Test frontend
        curl -f "$STAGING_URL" || {
          echo "‚ùå Frontend health check failed"
          exit 1
        }
        
        echo "‚úÖ Staging smoke tests passed"
    
    - name: Run E2E tests on staging
      working-directory: ./ui-tests
      env:
        BASE_URL: https://staging.alchemorsel.com
        API_BASE_URL: https://staging.alchemorsel.com/api
        HEADLESS: true
        TEST_USER_EMAIL: ${{ secrets.STAGING_TEST_USER_EMAIL }}
        TEST_USER_PASSWORD: ${{ secrets.STAGING_TEST_USER_PASSWORD }}
      run: |
        npm ci
        
        echo "üß™ Running E2E tests on staging..."
        node tests/comprehensive-e2e.test.js || {
          echo "‚ùå E2E tests failed on staging"
          exit 1
        }
        
        echo "‚úÖ E2E tests passed on staging"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-images, deploy-staging]
    environment: production
    if: >
      (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v')) &&
      (needs.deploy-staging.result == 'success' || github.event.inputs.force_deploy == 'true') &&
      (github.event.inputs.environment == 'production' || github.event_name == 'push')
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Create deployment
      uses: actions/github-script@v7
      id: deployment
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            environment: 'production',
            description: 'Production deployment',
            auto_merge: false,
            required_contexts: []
          });
          return deployment.data.id;
    
    - name: Deploy to production
      env:
        BACKEND_IMAGE: ${{ needs.build-images.outputs.backend-image }}
        FRONTEND_IMAGE: ${{ needs.build-images.outputs.frontend-image }}
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_PRODUCTION }}
        DEPLOYMENT_ID: ${{ steps.deployment.outputs.result }}
      run: |
        echo "üöÄ Deploying to production environment..."
        echo "Backend image: $BACKEND_IMAGE"
        echo "Frontend image: $FRONTEND_IMAGE"
        
        # Update deployment status to in_progress
        curl -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
          -d '{"state":"in_progress","description":"Deploying to production"}'
        
        # Install kubectl
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Setup kubeconfig
        mkdir -p ~/.kube
        echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
        
        # Blue-green deployment strategy
        echo "Deploying to production (blue-green)..."
        
        # Deploy to green environment first
        kubectl set image deployment/alchemorsel-backend-green backend=$BACKEND_IMAGE -n production
        kubectl set image deployment/alchemorsel-frontend-green frontend=$FRONTEND_IMAGE -n production
        
        # Wait for green deployment to be ready
        kubectl rollout status deployment/alchemorsel-backend-green -n production --timeout=600s
        kubectl rollout status deployment/alchemorsel-frontend-green -n production --timeout=600s
        
        echo "‚úÖ Production deployment completed"
    
    - name: Run production smoke tests
      env:
        DEPLOYMENT_ID: ${{ steps.deployment.outputs.result }}
      run: |
        echo "üß™ Running smoke tests on production..."
        
        PRODUCTION_URL="https://alchemorsel.com"
        
        # Test backend health
        curl -f "$PRODUCTION_URL/api/health" || {
          echo "‚ùå Production backend health check failed"
          
          # Update deployment status to failure
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
            -d '{"state":"failure","description":"Production health check failed"}'
          
          exit 1
        }
        
        # Test frontend
        curl -f "$PRODUCTION_URL" || {
          echo "‚ùå Production frontend health check failed"
          
          # Update deployment status to failure
          curl -X POST \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
            -d '{"state":"failure","description":"Production health check failed"}'
          
          exit 1
        }
        
        echo "‚úÖ Production smoke tests passed"
        
        # Update deployment status to success
        curl -X POST \
          -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          -H "Accept: application/vnd.github.v3+json" \
          "https://api.github.com/repos/${{ github.repository }}/deployments/$DEPLOYMENT_ID/statuses" \
          -d '{"state":"success","description":"Production deployment successful"}'
    
    - name: Switch traffic to green
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_PRODUCTION }}
      run: |
        echo "üîÑ Switching traffic to green environment..."
        
        # Setup kubeconfig
        mkdir -p ~/.kube
        echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
        
        # Update service selectors to point to green
        kubectl patch service alchemorsel-backend -n production -p '{"spec":{"selector":{"version":"green"}}}'
        kubectl patch service alchemorsel-frontend -n production -p '{"spec":{"selector":{"version":"green"}}}'
        
        echo "‚úÖ Traffic switched to green environment"
    
    - name: Cleanup old blue environment
      env:
        KUBE_CONFIG: ${{ secrets.KUBE_CONFIG_PRODUCTION }}
      run: |
        echo "üßπ Cleaning up blue environment..."
        
        # Setup kubeconfig
        mkdir -p ~/.kube
        echo "$KUBE_CONFIG" | base64 -d > ~/.kube/config
        
        # Scale down blue environment (keep for quick rollback)
        kubectl scale deployment alchemorsel-backend-blue --replicas=1 -n production
        kubectl scale deployment alchemorsel-frontend-blue --replicas=1 -n production
        
        echo "‚úÖ Blue environment scaled down"

  notify-deployment:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    
    steps:
    - name: Notify success
      if: needs.deploy-production.result == 'success'
      run: |
        echo "üéâ Production deployment successful!"
        # Add your notification logic here (Slack, Discord, email, etc.)
        
        # Example Slack notification
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"üéâ Alchemorsel v${{ github.sha }} deployed to production successfully!"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}
    
    - name: Notify failure
      if: needs.deploy-production.result == 'failure'
      run: |
        echo "‚ùå Production deployment failed!"
        # Add your failure notification logic here
        
        # Example Slack notification
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"‚ùå Alchemorsel deployment to production failed! Please check the logs."}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}